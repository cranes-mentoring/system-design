### Урок: Блокировки в PostgreSQL

#### Введение
Блокировки в PostgreSQL служат для управления доступом к данным, обеспечивая целостность данных при одновременном доступе нескольких транзакций. Понимание блокировок критически важно для разработчиков и администраторов баз данных, чтобы предотвратить взаимоблокировки и гарантировать высокую производительность приложений.

#### Основные типы блокировок

1. **ROW LEVEL LOCKS** (Блокировки на уровне строк):
    - **FOR UPDATE**: Блокирует строки для обновления, предотвращая их изменение или выборку другими транзакциями с `FOR UPDATE`.
    - **FOR NO KEY UPDATE**: Похоже на `FOR UPDATE`, но позволяет другим транзакциям изменять неключевые столбцы.
    - **FOR SHARE**: Блокирует строки от изменений, позволяя другим транзакциям выбирать их с `FOR SHARE`.
    - **FOR KEY SHARE**: Наименее ограничительная, позволяет изменения, не затрагивающие ключи.

2. **TABLE LEVEL LOCKS** (Блокировки на уровне таблицы):
    - **ACCESS SHARE**: Наименее ограничительная, используется при чтении данных.
    - **ROW SHARE**: Используется транзакциями, которые модифицируют строки.
    - **ROW EXCLUSIVE**: Блокирует другие транзакции от получения этой же блокировки или блокировок, модифицирующих таблицу.
    - **SHARE UPDATE EXCLUSIVE**: Для операций, которые должны быть одиночными на таблице, но не мешают чтению или изменению данных.
    - **SHARE**: Позволяет чтение и блокировку на уровне строки, но не изменение структуры.
    - **SHARE ROW EXCLUSIVE**: Строже, чем ROW EXCLUSIVE, предотвращает конкурирующие изменения.
    - **EXCLUSIVE**: Блокирует большинство операций, но позволяет чтение.
    - **ACCESS EXCLUSIVE**: Самая строгая, блокирует любые другие операции над таблицей.

3. **ADVISORY LOCKS** (Советские блокировки):
   Пользовательские блокировки, которые не привязаны к конкретным объектам БД. Могут использоваться для реализации сложной логики блокировок на уровне приложения.

#### Примеры использования

- **ROW LEVEL LOCKS**:

  Допустим, есть таблица `users` и нужно обновить запись без конфликтов:
  ```sql
  BEGIN;
  SELECT * FROM users WHERE id = 1 FOR UPDATE;
  UPDATE users SET name = 'New Name' WHERE id = 1;
  COMMIT;
  ```

- **TABLE LEVEL LOCKS**:

  Блокировка таблицы для обновления данных без вмешательства других транзакций:
  ```sql
  BEGIN;
  LOCK TABLE users IN SHARE ROW EXCLUSIVE MODE;
  UPDATE users SET name = 'Updated Name' WHERE country = 'USA';
  COMMIT;
  ```

- **ADVISORY LOCKS**:

  Блокировка на уровне приложения, например, для обеспечения уникальности операции:
  ```sql
  SELECT pg_advisory_lock(123456);
  -- Выполнение операции, которая должна быть уникальной
  SELECT pg_advisory_unlock(123456);
  ```

#### Лучшие практики

- Избегайте длительных транзакций с блокировками, особенно в высоконагруженных системах.
- Используйте подходящий уровень блокировки для задачи: не более строгий, чем необходимо.
- Мониторьте и анализируйте блокировки в вашей системе с помощью `pg_stat_activity` и `pg_locks`.
- Разработайте стратегию обработки взаимоблокировок, чтобы минимизировать их влияние на производительность.

#### В проекте:
- сделаем очистку по N записей шедулером
- имеет смысл обдумать, какую блокировку мы будем использовать?
