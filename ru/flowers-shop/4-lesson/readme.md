### Урок 4: Работа с PostgreSQL и добавление таблицы истории заказов

#### Цели урока:
- Изучить основы работы с PostgreSQL
- Создать таблицу истории заказов для хранения информации о предыдущих заказах пользователей
- Освоить основные операции с базой данных в контексте нашего проекта магазина цветов

#### Часть 1: Введение в PostgreSQL

PostgreSQL - это мощная объектно-реляционная система управления базами данных,
которая позволяет нам хранить и оперировать большим объемом структурированных данных.
В этой части мы ознакомимся с основными принципами работы с PostgreSQL, 
включая создание таблиц, добавление данных и выполнение запросов.

#### Часть 2: Создание таблицы истории заказов

Для хранения информации о предыдущих заказах пользователей мы создадим новую таблицу в нашей базе данных PostgreSQL. 
Мы определим структуру таблицы, включая необходимые поля для хранения данных о заказах, а также связи с другими таблицами.

#### Часть 3: Основные операции с базой данных

После создания таблицы истории заказов мы изучим основные операции с базой данных,
такие как добавление, чтение, обновление и удаление данных. 
Мы научимся выполнять SQL запросы для взаимодействия с нашей базой данных, используя язык SQL.

#### Часть 4: Интеграция таблицы истории заказов в наше приложение

После создания таблицы мы интегрируем ее в наше приложение, обеспечивая возможность записи информации о заказах 
пользователей при создании новых заказов. Мы обновим наш API для включения новых эндпоинтов, позволяющих
получать информацию о предыдущих заказах.


#### Часть 5: deep dive
### Урок: Мастер-класс по индексам в PostgreSQL

#### Понимание индексов в PostgreSQL
- **Определение и работа индекса**: Индекс ускоряет чтение данных, указывая на местоположение данных в таблице, как индекс в книге.
- **Структура индекса**: Большинство индексов в PostgreSQL основаны на B-деревьях, эффективной структуре для хранения отсортированных данных.

#### Типы индексов в PostgreSQL и примеры создания

##### B-Tree
- **Использование**: Оптимален для общих сценариев, таких как сравнения с использованием операторов =, <, >, <=, >=.
- **Пример создания**:
  ```sql
  CREATE INDEX idx_name ON table_name USING btree(column_name);
  ```
- **Типы данных**: Числа, строки, даты.

##### Hash
- **Использование**: Хорош для операций сравнения равенства (=).
- **Пример создания**:
  ```sql
  CREATE INDEX idx_name ON table_name USING hash(column_name);
  ```
- **Типы данных**: Подходит для простых типов данных, таких как целые числа и строки фиксированной длины.

##### GIN (Generalized Inverted Index)
- **Использование**: Идеален для составных значений, таких как массивы, JSONB, hstore.
- **Пример создания**:
  ```sql
  CREATE INDEX idx_name ON table_name USING gin(column_name);
  ```
- **Типы данных**: Массивы, текст, JSONB.

##### GiST (Generalized Search Tree)
- **Использование**: Применяется для полнотекстового поиска и геопространственных запросов.
- **Пример создания**:
  ```sql
  CREATE INDEX idx_name ON table_name USING gist(column_name);
  ```
- **Типы данных**: Текст, геометрия, география.

##### BRIN (Block Range Indexes)
- **Использование**: Эффективен для очень больших таблиц, где данные физически упорядочены по индексируемому столбцу.
- **Пример создания**:
  ```sql
  CREATE INDEX idx_name ON table_name USING brin(column_name);
  ```
- **Типы данных**: Лучше всего подходит для данных, которые естественно упорядочены, например, даты и временные метки.

#### Проектирование и использование индексов
- **Когда создавать индексы**: Создавайте индексы для столбцов, часто используемых в WHERE, JOIN или в качестве части ORDER BY.
- **Проектирование индексов для запросов**: Анализируйте свои запросы и данные, чтобы выбрать наиболее подходящий тип индекса.
- **Мониторинг и тюнинг индексов**: Используйте `EXPLAIN` и `EXPLAIN ANALYZE` для оценки эффективности ваших индексов.

#### Лучшие практики и частые ошибки
- **Поддержка индексов**: Регулярно пересматривайте и обновляйте индексы для поддержания производительности.
- **Распространенные ошибки**: Избегайте избыточного индексирования; каждый индекс увеличивает время, необходимое для операций вставки, обновления и удаления.

#### Практическое задание
Определите наиболее часто используемые столбцы в ваших запросах к большой таблице.
Создайте подходящие индексы и сравните производительность запросов до и после их добавления с помощью `EXPLAIN ANALYZE`.

---

### Дополнение: Зачем важно удалять по n штук шедулером

Удаление старых записей из базы данных является важной задачей, 
особенно в случае хранения большого объема данных на протяжении длительного времени.
Помимо освобождения места в базе данных, правильное удаление данных также способствует оптимизации производительности системы.
Удаление записей по 100 штук шедулером позволяет снизить нагрузку на базу данных, предотвращая возможные блокировки и снижение производительности во время выполнения операции удаления.

#### Пользовательский опыт

Эффективное удаление устаревших данных имеет прямое влияние на пользовательский опыт. Когда база данных перегружена и работает медленно из-за накопившихся записей, это может привести к задержкам в выполнении запросов пользователей. Например, если пользователь хочет просмотреть свой заказ или внести изменения в данные, долгий ответ от сервера может вызвать разочарование и негативное впечатление.

#### Предотвращение блокировок и сбоев

Более того, удаление данных по 100 штук шедулером помогает предотвратить возможные блокировки и сбои базы данных. 
Когда большое количество записей удаляется одновременно, это может вызвать длительные блокировки таблицы или даже привести к сбоям в работе базы данных. 
Разбиение операции удаления на небольшие партии позволяет избежать подобных проблем и обеспечить более стабильную работу системы.

---
### Дополнительные материалы:
[Postgres Pro](https://postgrespro.ru/education/books/introbook)
[8 книг по PostgreSQL: от баз данных с «нуля» для самоучек до руководства про БД в облаках](https://habr.com/ru/companies/selectel/articles/713714/)
