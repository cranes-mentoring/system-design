### Урок 4: Работа с PostgreSQL и добавление таблицы истории заказов

#### Цели урока:
- Ознакомление с основами работы с PostgreSQL
- Создание таблицы истории заказов для хранения информации о предыдущих заказах пользователей
- Освоение основных операций с базой данных в контексте проекта магазина цветов

#### Часть 1: Введение в PostgreSQL

PostgreSQL - мощная система управления базами данных, позволяющая хранить и оперировать большим объемом структурированных данных. В этой части урока мы познакомимся с основами работы с PostgreSQL, включая создание таблиц, добавление данных и выполнение запросов.

#### Часть 2: Создание таблицы истории заказов

Для хранения информации о предыдущих заказах пользователей мы создадим новую таблицу в нашей базе данных PostgreSQL. Определим структуру таблицы, включая необходимые поля для хранения данных о заказах, а также связи с другими таблицами.

**Пример структуры таблицы `order_history`:**
- `order_id`: Уникальный идентификатор заказа (целое число, первичный ключ)
- `customer_id`: Уникальный идентификатор пользователя (целое число, внешний ключ связи с таблицей пользователей)
- `order_date`: Дата размещения заказа (дата и время)
- `total_amount`: Общая сумма заказа (десятичное число)

--- 

Рассчитаем стоимость хранения:
Конечно! Давайте рассмотрим пример структуры данных для таблицы `Orders` с заказами. В этой таблице мы будем хранить информацию о заказах, включая идентификатор заказа, дату, сумму, клиента и другие детали.

### Структура данных для таблицы "Orders"

| Поле           | Тип данных | Описание                                      |
|----------------|------------|-----------------------------------------------|
| `order_id`     | INT        | Уникальный идентификатор заказа               |
| `order_date`   | DATE       | Дата размещения заказа                        |
| `total_amount` | DECIMAL    | Общая сумма заказа                            |
| `customer_id`  | INT        | Идентификатор клиента                         |
| `shipping_address` | VARCHAR | Адрес доставки заказа                         |
| `payment_method` | VARCHAR  | Способ оплаты (например, кредитная карта)     |
| `status`       | VARCHAR    | Статус заказа (например, "в обработке", "доставлен") |

Пример SQL-запроса для создания такой таблицы:

```sql
CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    order_date DATE,
    total_amount DECIMAL(10, 2),
    customer_id INT,
    shipping_address VARCHAR(255),
    payment_method VARCHAR(50),
    status VARCHAR(20)
);
```
Расчет веса базы данных:

1. **Размер записи**:
  - Предположим, что каждая запись в таблице `Orders` имеет следующий размер:
    - `order_id`: INT (4 байта)
    - `order_date`: DATE (4 байта)
    - `total_amount`: DECIMAL(10, 2) (8 байт)
    - `customer_id`: INT (4 байта)
    - `shipping_address`: VARCHAR(255) (255 байт)
    - `payment_method`: VARCHAR(50) (50 байт)
    - `status`: VARCHAR(20) (20 байт)
  - Общий размер одной записи: **345 байт**.

2. **Общий объем данных**:
  - Общее количество запросов: **47 304 000**.
  - Общий объем данных: (47 304 000 * 345 байт = 16 310 280 000 байт).

3. **Преобразование в гигабайты (GB)**:
  - Общий объем данных в гигабайтах: (16 310 280 000 {байт} / (1024^3) = 15 548.25ГБ).

Таким образом, вес базы данных с указанной структурой составит приблизительно **15 548.25 ГБ**.



---
#### Часть 3: Основные операции с базой данных

После создания таблицы истории заказов мы изучим основные операции с базой данных, такие как добавление, чтение, обновление и удаление данных. Мы научимся выполнять SQL запросы для взаимодействия с нашей базой данных, используя язык SQL.

**Примеры операций:**
- Добавление нового заказа в таблицу `order_history`
  ```sql
  INSERT INTO order_history (order_id, customer_id, order_date, total_amount)
  VALUES (1, 123, '2024-04-05', 50.00);
  ```

- Получение списка всех заказов пользователя с `customer_id` равным 123
  ```sql
  SELECT * FROM order_history WHERE customer_id = 123;
  ```

- Обновление суммы заказа для конкретного заказа
  ```sql
  UPDATE order_history SET total_amount = 60.00 WHERE order_id = 1;
  ```

- Удаление заказа из истории по его `order_id`
  ```sql
  DELETE FROM order_history WHERE order_id = 1;
  ```

#### Часть 4: Интеграция таблицы истории заказов в приложение

После создания таблицы мы интегрируем ее в наше приложение, чтобы сохранять информацию о заказах пользователей при создании новых заказов. Мы обновим наше API для включения новых эндпоинтов, позволяющих получать информацию о предыдущих заказах.

#### Углубленное изучение: Мастер-класс по индексам в PostgreSQL

В данной части урока мы рассмотрим важность индексов в PostgreSQL и различные типы индексов, которые можно создавать для оптимизации производительности базы данных.

##### Понимание индексов в PostgreSQL
- **Определение и работа индекса**: Индекс ускоряет чтение данных, указывая на местоположение данных в таблице, как индекс в книге.
- **Типы индексов**: B-Tree, Hash, GIN, GiST, BRIN.

##### Примеры создания индексов
- **B-Tree**: Оптимален для общих сценариев сравнения.
  ```sql
  CREATE INDEX idx_name ON table_name USING btree(column_name);
  ```

- **Hash**: Хорош для операций сравнения равенства.
  ```sql
  CREATE INDEX idx_name ON table_name USING hash(column_name);
  ```

- **GIN**: Идеален для составных значений, таких как массивы или JSONB.
  ```sql
  CREATE INDEX idx_name ON table_name USING gin(column_name);
  ```

- **GiST**: Применяется для полнотекстового поиска и геопространственных запросов.
  ```sql
  CREATE INDEX idx_name ON table_name USING gist(column_name);
  ```

- **BRIN**: Эффективен для больших таблиц с упорядоченными данными.
  ```sql
  CREATE INDEX idx_name ON table_name USING brin(column_name);
  ```

##### Проектирование и использование индексов
- **Когда создавать индексы**: Для столбцов, часто используемых в условиях `WHERE`, `JOIN` или `ORDER BY`.
- **Мониторинг и тюнинг**: Использование `EXPLAIN` и `EXPLAIN ANALYZE` для оценки эффективности индексов.

#### Практическое задание

Определите наиболее часто используемые столбцы в ваших запросах к большой таблице. Создайте подходящие индексы и сравните производительность запросов до и после добавления индексов с помощью `EXPLAIN ANALYZE`.

---

### Дополнение: Зачем важно удалять данные шедулером порциями

Удаление устаревших записей из базы данных является важной задачей для поддержания производительности и предотвращения блокировок. Частое удаление больших объемов

данных может привести к проблемам с производительностью и возможным сбоям. Шедулер, который удаляет данные по небольшим порциям (например, по 100 штук), позволяет снизить нагрузку на базу данных и избежать возможных проблем.

#### Пользовательский опыт

Эффективное удаление устаревших данных напрямую влияет на пользовательский опыт, предотвращая задержки и обеспечивая стабильную работу системы.

#### Предотвращение блокировок и сбоев

Регулярное удаление данных шедулером порциями помогает предотвратить блокировки и сбои базы данных, обеспечивая более стабильную и эффективную работу системы.

### Уровни изоляции транзакций в SQL базах данных
#### Введение

Уровни изоляции транзакций определяют степень видимости изменений, внесенных одной транзакцией, для других транзакций. В SQL базах данных существует несколько уровней изоляции, каждый из которых имеет свои особенности и влияние на поведение транзакций. В этом уроке мы рассмотрим каждый уровень изоляции подробно с примерами и описанием.

---

#### Уровень изоляции READ UNCOMMITTED

Уровень изоляции READ UNCOMMITTED позволяет транзакциям видеть неподтвержденные изменения, внесенные другими транзакциями. Этот уровень изоляции предоставляет самый низкий уровень защиты данных и может привести к чтению "грязных данных".

**Пример**: Предположим, что есть таблица `users`:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50)
);
```

Теперь рассмотрим две транзакции:

```sql
-- Транзакция A
BEGIN;
UPDATE users SET name = 'Alice' WHERE id = 1;

-- Транзакция B
BEGIN;
SELECT * FROM users WHERE id = 1;
```

В данном случае, транзакция B может прочитать измененные данные (например, имя "Alice"), даже если транзакция A еще не подтвердила свои изменения.

#### Уровень изоляции READ COMMITTED

Уровень изоляции READ COMMITTED гарантирует, что транзакции видят только подтвержденные изменения. Транзакции, которые выполняются параллельно с другими транзакциями, не видят неподтвержденные изменения.

**Пример**:

```sql
-- Транзакция A
BEGIN;
UPDATE users SET name = 'Bob' WHERE id = 2;
COMMIT;

-- Транзакция B
BEGIN;
SELECT * FROM users WHERE id = 2;
```

В этом случае, транзакция B не увидит изменения, внесенные транзакцией A, пока они не будут подтверждены.

#### Уровень изоляции REPEATABLE READ

Уровень изоляции REPEATABLE READ гарантирует, что транзакции будут видеть одни и те же данные во время своего выполнения, даже если другие транзакции вносят изменения в эти данные.

**Пример**:

```sql
-- Транзакция A
BEGIN;
SELECT * FROM users WHERE id = 3;

-- Транзакция B
BEGIN;
UPDATE users SET name = 'Charlie' WHERE id = 3;
COMMIT;

-- Транзакция A (повторно)
SELECT * FROM users WHERE id = 3;
```

В данном случае, результаты первого и второго запросов в транзакции A будут одинаковыми, даже если транзакция B внесла изменения.

#### Уровень изоляции SERIALIZABLE

Уровень изоляции SERIALIZABLE обеспечивает самый высокий уровень изоляции, гарантируя, что транзакции выполняются так, будто они выполняются последовательно, а не параллельно. Этот уровень изоляции предотвращает аномалии, такие как потерянное обновление и фантомное чтение.

**Пример**:

```sql
-- Транзакция A
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM users WHERE id = 4;

-- Транзакция B
BEGIN;
UPDATE users SET name = 'Dave' WHERE id = 4;
COMMIT;

-- Транзакция A (повторно)
SELECT * FROM users WHERE id = 4;
```

В этом случае, результаты первого и второго запросов в транзакции A будут одинаковыми, даже если транзакция B внесла изменения.

---

#### Заключение

Уровни изоляции транзакций предоставляют различные уровни гарантий относительно видимости изменений для параллельных транзакций. Понимание этих уровней позволяет разработчикам выбирать наиболее подходящий уровень для своих приложений в зависимости от требований к целостности данных и производительности.

---
### Дополнительные материалы:
[Postgres Pro](https://postgrespro.ru/education/books/introbook)
[8 книг по PostgreSQL: от баз данных с «нуля» для самоучек до руководства про БД в облаках](https://habr.com/ru/companies/selectel/articles/713714/)

---
