### Урок 4: Работа с PostgreSQL и добавление таблицы истории заказов

#### Цели урока:
- Изучить основы работы с PostgreSQL
- Создать таблицу истории заказов для хранения информации о предыдущих заказах пользователей
- Освоить основные операции с базой данных в контексте нашего проекта магазина цветов

#### Часть 1: Введение в PostgreSQL

PostgreSQL - это мощная объектно-реляционная система управления базами данных,
которая позволяет нам хранить и оперировать большим объемом структурированных данных.
В этой части мы ознакомимся с основными принципами работы с PostgreSQL, 
включая создание таблиц, добавление данных и выполнение запросов.

#### Часть 2: Создание таблицы истории заказов

Для хранения информации о предыдущих заказах пользователей мы создадим новую таблицу в нашей базе данных PostgreSQL. 
Мы определим структуру таблицы, включая необходимые поля для хранения данных о заказах, а также связи с другими таблицами.

#### Часть 3: Основные операции с базой данных

После создания таблицы истории заказов мы изучим основные операции с базой данных,
такие как добавление, чтение, обновление и удаление данных. 
Мы научимся выполнять SQL запросы для взаимодействия с нашей базой данных, используя язык SQL.

#### Часть 4: Интеграция таблицы истории заказов в наше приложение

После создания таблицы мы интегрируем ее в наше приложение, обеспечивая возможность записи информации о заказах 
пользователей при создании новых заказов. Мы обновим наш API для включения новых эндпоинтов, позволяющих
получать информацию о предыдущих заказах.


#### Часть 5: deep dive
### Урок: Мастер-класс по индексам в PostgreSQL

#### Понимание индексов в PostgreSQL
- **Определение и работа индекса**: Индекс ускоряет чтение данных, указывая на местоположение данных в таблице, как индекс в книге.
- **Структура индекса**: Большинство индексов в PostgreSQL основаны на B-деревьях, эффективной структуре для хранения отсортированных данных.

#### Типы индексов в PostgreSQL и примеры создания

##### B-Tree
- **Использование**: Оптимален для общих сценариев, таких как сравнения с использованием операторов =, <, >, <=, >=.
- **Пример создания**:
  ```sql
  CREATE INDEX idx_name ON table_name USING btree(column_name);
  ```
- **Типы данных**: Числа, строки, даты.

##### Hash
- **Использование**: Хорош для операций сравнения равенства (=).
- **Пример создания**:
  ```sql
  CREATE INDEX idx_name ON table_name USING hash(column_name);
  ```
- **Типы данных**: Подходит для простых типов данных, таких как целые числа и строки фиксированной длины.

##### GIN (Generalized Inverted Index)
- **Использование**: Идеален для составных значений, таких как массивы, JSONB, hstore.
- **Пример создания**:
  ```sql
  CREATE INDEX idx_name ON table_name USING gin(column_name);
  ```
- **Типы данных**: Массивы, текст, JSONB.

##### GiST (Generalized Search Tree)
- **Использование**: Применяется для полнотекстового поиска и геопространственных запросов.
- **Пример создания**:
  ```sql
  CREATE INDEX idx_name ON table_name USING gist(column_name);
  ```
- **Типы данных**: Текст, геометрия, география.

##### BRIN (Block Range Indexes)
- **Использование**: Эффективен для очень больших таблиц, где данные физически упорядочены по индексируемому столбцу.
- **Пример создания**:
  ```sql
  CREATE INDEX idx_name ON table_name USING brin(column_name);
  ```
- **Типы данных**: Лучше всего подходит для данных, которые естественно упорядочены, например, даты и временные метки.

#### Проектирование и использование индексов
- **Когда создавать индексы**: Создавайте индексы для столбцов, часто используемых в WHERE, JOIN или в качестве части ORDER BY.
- **Проектирование индексов для запросов**: Анализируйте свои запросы и данные, чтобы выбрать наиболее подходящий тип индекса.
- **Мониторинг и тюнинг индексов**: Используйте `EXPLAIN` и `EXPLAIN ANALYZE` для оценки эффективности ваших индексов.

#### Лучшие практики и частые ошибки
- **Поддержка индексов**: Регулярно пересматривайте и обновляйте индексы для поддержания производительности.
- **Распространенные ошибки**: Избегайте избыточного индексирования; каждый индекс увеличивает время, необходимое для операций вставки, обновления и удаления.

#### Практическое задание
Определите наиболее часто используемые столбцы в ваших запросах к большой таблице.
Создайте подходящие индексы и сравните производительность запросов до и после их добавления с помощью `EXPLAIN ANALYZE`.

---

### Дополнение: Зачем важно удалять по n штук шедулером

Удаление старых записей из базы данных является важной задачей, 
особенно в случае хранения большого объема данных на протяжении длительного времени.
Помимо освобождения места в базе данных, правильное удаление данных также способствует оптимизации производительности системы.
Удаление записей по 100 штук шедулером позволяет снизить нагрузку на базу данных, предотвращая возможные блокировки и снижение производительности во время выполнения операции удаления.

#### Пользовательский опыт

Эффективное удаление устаревших данных имеет прямое влияние на пользовательский опыт. Когда база данных перегружена и работает медленно из-за накопившихся записей, это может привести к задержкам в выполнении запросов пользователей. Например, если пользователь хочет просмотреть свой заказ или внести изменения в данные, долгий ответ от сервера может вызвать разочарование и негативное впечатление.

#### Предотвращение блокировок и сбоев

Более того, удаление данных по 100 штук шедулером помогает предотвратить возможные блокировки и сбои базы данных. 
Когда большое количество записей удаляется одновременно, это может вызвать длительные блокировки таблицы или даже привести к сбоям в работе базы данных. 
Разбиение операции удаления на небольшие партии позволяет избежать подобных проблем и обеспечить более стабильную работу системы.

### Урок: Уровни изоляции транзакций в SQL базах данных

#### Введение

Уровни изоляции транзакций определяют степень видимости изменений, внесенных одной транзакцией, для других транзакций. В SQL базах данных существует несколько уровней изоляции, каждый из которых имеет свои особенности и влияние на поведение транзакций. В этом уроке мы рассмотрим каждый уровень изоляции подробно с примерами и описанием.

---

#### Уровень изоляции READ UNCOMMITTED

Уровень изоляции READ UNCOMMITTED позволяет транзакциям видеть неподтвержденные изменения, внесенные другими транзакциями. Этот уровень изоляции предоставляет самый низкий уровень защиты данных и может привести к чтению "грязных данных".

**Пример**: Предположим, что есть таблица `users`:

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50)
);
```

Теперь рассмотрим две транзакции:

```sql
-- Транзакция A
BEGIN;
UPDATE users SET name = 'Alice' WHERE id = 1;

-- Транзакция B
BEGIN;
SELECT * FROM users WHERE id = 1;
```

В данном случае, транзакция B может прочитать измененные данные (например, имя "Alice"), даже если транзакция A еще не подтвердила свои изменения.

#### Уровень изоляции READ COMMITTED

Уровень изоляции READ COMMITTED гарантирует, что транзакции видят только подтвержденные изменения. Транзакции, которые выполняются параллельно с другими транзакциями, не видят неподтвержденные изменения.

**Пример**:

```sql
-- Транзакция A
BEGIN;
UPDATE users SET name = 'Bob' WHERE id = 2;
COMMIT;

-- Транзакция B
BEGIN;
SELECT * FROM users WHERE id = 2;
```

В этом случае, транзакция B не увидит изменения, внесенные транзакцией A, пока они не будут подтверждены.

#### Уровень изоляции REPEATABLE READ

Уровень изоляции REPEATABLE READ гарантирует, что транзакции будут видеть одни и те же данные во время своего выполнения, даже если другие транзакции вносят изменения в эти данные.

**Пример**:

```sql
-- Транзакция A
BEGIN;
SELECT * FROM users WHERE id = 3;

-- Транзакция B
BEGIN;
UPDATE users SET name = 'Charlie' WHERE id = 3;
COMMIT;

-- Транзакция A (повторно)
SELECT * FROM users WHERE id = 3;
```

В данном случае, результаты первого и второго запросов в транзакции A будут одинаковыми, даже если транзакция B внесла изменения.

#### Уровень изоляции SERIALIZABLE

Уровень изоляции SERIALIZABLE обеспечивает самый высокий уровень изоляции, гарантируя, что транзакции выполняются так, будто они выполняются последовательно, а не параллельно. Этот уровень изоляции предотвращает аномалии, такие как потерянное обновление и фантомное чтение.

**Пример**:

```sql
-- Транзакция A
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM users WHERE id = 4;

-- Транзакция B
BEGIN;
UPDATE users SET name = 'Dave' WHERE id = 4;
COMMIT;

-- Транзакция A (повторно)
SELECT * FROM users WHERE id = 4;
```

В этом случае, результаты первого и второго запросов в транзакции A будут одинаковыми, даже если транзакция B внесла изменения.

---

#### Заключение

Уровни изоляции транзакций предоставляют различные уровни гарантий относительно видимости изменений для параллельных транзакций. Понимание этих уровней позволяет разработчикам выбирать наиболее подходящий уровень для своих приложений в зависимости от требований к целостности данных и производительности.

---
### Дополнительные материалы:
[Postgres Pro](https://postgrespro.ru/education/books/introbook)
[8 книг по PostgreSQL: от баз данных с «нуля» для самоучек до руководства про БД в облаках](https://habr.com/ru/companies/selectel/articles/713714/)

---
