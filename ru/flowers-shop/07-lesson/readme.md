### Урок: Управление блокировками в PostgreSQL

#### Введение в блокировки

Блокировки в PostgreSQL используются для контроля доступа к данным в многопользовательской среде, обеспечивая целостность данных и избегая конфликтов между транзакциями. Понимание типов блокировок важно для разработчиков и администраторов баз данных, чтобы эффективно управлять работой приложений.

#### Основные типы блокировок

1. **Блокировки на уровне строк (ROW LEVEL LOCKS)**:
    - **FOR UPDATE**: Блокирует строки для обновления, предотвращая их изменение или выборку другими транзакциями с использованием `FOR UPDATE`.
    - **FOR NO KEY UPDATE**: Похоже на `FOR UPDATE`, но позволяет другим транзакциям изменять неключевые столбцы.
    - **FOR SHARE**: Блокирует строки от изменений, разрешая другим транзакциям их выборку с использованием `FOR SHARE`.
    - **FOR KEY SHARE**: Самая слабая блокировка, позволяющая изменения, которые не затрагивают ключевые столбцы.

2. **Блокировки на уровне таблицы (TABLE LEVEL LOCKS)**:
    - **ACCESS SHARE**: Используется для чтения данных без блокировки других операций чтения.
    - **ROW SHARE**: Используется транзакциями, которые модифицируют строки в таблице.
    - **ROW EXCLUSIVE**: Блокирует другие транзакции от получения той же или подобной блокировки на таблицу.
    - **SHARE UPDATE EXCLUSIVE**: Для операций, которые должны быть единственными на таблице, но не блокируют чтение или изменение данных.
    - **SHARE**: Позволяет чтение данных и блокировку строк, но не изменение структуры таблицы.
    - **SHARE ROW EXCLUSIVE**: Более строгая, чем ROW EXCLUSIVE, предотвращает конкурентные изменения.
    - **EXCLUSIVE**: Блокирует большинство операций, но разрешает чтение данных.
    - **ACCESS EXCLUSIVE**: Самая строгая блокировка, предотвращающая любые другие операции над таблицей.

3. **Пользовательские блокировки (ADVISORY LOCKS)**:
   Пользовательские блокировки, которые не привязаны к конкретным объектам базы данных. Используются для реализации сложной логики блокировок на уровне приложения.

#### Примеры использования блокировок

- **Блокировки на уровне строк**:

```sql
-- Блокировка строки для обновления
BEGIN;
SELECT * FROM users WHERE id = 1 FOR UPDATE;
UPDATE users SET name = 'Новое имя' WHERE id = 1;
COMMIT;
```

- **Блокировки на уровне таблицы**:
```sql
-- Блокировка таблицы для чтения и обновления данных
BEGIN;
LOCK TABLE users IN SHARE ROW EXCLUSIVE MODE;
UPDATE users SET name = 'Обновленное имя' WHERE country = 'USA';
COMMIT;
```

- **Пользовательские блокировки**:
```sql
-- Использование советской блокировки для уникальной операции
SELECT pg_advisory_lock(123456);
-- Выполнение операции, которая должна быть уникальной
SELECT pg_advisory_unlock(123456);
```

Пользовательские блокировки (Advisory Locks) в PostgreSQL не блокируют таблицы или строки непосредственно.
Они предоставляют механизм для приложений, позволяющий устанавливать блокировки на произвольные ключи. 
Это означает, что влияние блокировки определяется логикой приложения, а не базой данных.

Пользовательские блокировки (Advisory Locks) в PostgreSQL являются механизмом, который позволяет приложениям устанавливать 
блокировки на произвольные ключи, тем самым координируя действия между различными сессиями. 
Эти блокировки не влияют на логику транзакций и не блокируют доступ к данным на уровне базы данных. 
Они полезны для решения задач синхронизации, когда стандартных средств SQL недостаточно.

Когда вы используете функцию pg_advisory_lock(key) или любую другую функцию из семейства advisory lock, 
вы фактически устанавливаете блокировку на абстрактный идентификатор (ключ). 
Это не влияет напрямую на данные в таблице или на доступ к строкам таблицы. 

Блокировка уровня строки или таблицы в PostgreSQL управляется другими механизмами, такими как LOCK TABLE 
или обычные транзакционные блокировки на уровне строки, которые автоматически применяются при операциях 
SELECT FOR UPDATE, UPDATE, DELETE и т.д.

### Функции для работы с пользовательскими блокировками в PostgreSQL:

- `pg_advisory_lock(key)`: Блокирует заданный ключ до тех пор, пока не будет вызвана функция `pg_advisory_unlock` или не закончится сессия.
- `pg_try_advisory_lock(key)`: Пытается установить блокировку на ключ. Возвращает `true`, если блокировка установлена, и `false`, если установить блокировку не удалось.
- `pg_advisory_unlock(key)`: Снимает блокировку с заданного ключа.

### Пример использования:

Предположим, вы хотите координировать доступ к критической секции кода в разных сессиях вашего приложения.

#### Сценарий:

Вам необходимо обеспечить, чтобы только один пользователь мог выполнить определённую операцию в данный момент времени (например, обновление определённых данных).

#### Шаги:

1. **Установка блокировки:**

```sql
SELECT pg_advisory_lock(42);
```

Здесь `42` — это произвольный идентификатор блокировки. Вы можете выбрать любое число, которое будет однозначно идентифицировать блокировку для данной операции.

2. **Выполнение критической операции:**

```sql
UPDATE my_table SET status = 'Processing' WHERE id = 1;
```

Это действие будет выполняться только если текущая сессия успешно установила блокировку.

3. **Снятие блокировки:**

```sql
SELECT pg_advisory_unlock(42);
```

После выполнения операции блокировку следует снять, чтобы другие сессии могли продолжить работу с этой же частью кода.

### Обратите внимание:

- Если не снять блокировку, она останется активной до завершения сессии, что может привести к блокированию других сессий, которые также пытаются выполнить эту же операцию.
- Использование пользовательских блокировок требует тщательного планирования и управления, чтобы избежать взаимных блокировок (deadlocks) и других проблем с конкуренцией.

Таким образом, пользовательские блокировки в PostgreSQL позволяют разработчикам контролировать выполнение параллельных процессов на уровне приложения, обеспечивая эффективную и безопасную работу с критически важными данными.

### Лучшие практики при работе с блокировками

- Избегайте длительных транзакций с блокировками, чтобы минимизировать ожидание и блокирование других транзакций.
- Используйте наименее строгий уровень блокировки, который соответствует задаче, чтобы избежать излишней блокировки и конфликтов.
- Мониторьте и анализируйте блокировки с помощью системных каталогов PostgreSQL, таких как `pg_stat_activity` и `pg_locks`.
- Разработайте стратегию обработки взаимоблокировок, чтобы предотвратить их возникновение и минимизировать их влияние на производительность системы.
- Использование блокировок в PostgreSQL требует внимательного планирования и учета особенностей вашего приложения. Внимательно выбирайте типы блокировок и их уровни для обеспечения безопасной и эффективной работы с данными.


#### Применение в проекте

В проекте реализация механизма очистки данных по N записей с использованием шедулера может потребовать блокировки для безопасного удаления данных. Например, можно использовать `FOR UPDATE` для выборки и блокировки строк перед удалением их шедулером. Важно выбрать правильный уровень блокировки, чтобы избежать конфликтов и обеспечить целостность данных.


--- 


## Пессимистическая и оптимистическая блокировка 

### Пессимистическая блокировка

Пессимистическая блокировка часто реализуется с использованием операторов SQL, которые явно блокируют доступ к данным на время выполнения транзакции. Обычно это достигается с помощью команд `SELECT FOR UPDATE` или `SELECT FOR SHARE`.

**Пример:**

Представим, что у нас есть таблица `accounts` с колонками `id` и `balance`. Вы хотите обновить баланс, но сначала убедиться, что запись не будет изменена другой транзакцией.

```sql
BEGIN;

-- Заблокировать строку для обновления
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;

-- Выполнить обновление баланса
UPDATE accounts SET balance = balance + 100 WHERE id = 1;

COMMIT;
```

Здесь `FOR UPDATE` блокирует выбранную строку, предотвращая её изменение другими транзакциями до тех пор, пока текущая транзакция не завершится командой `COMMIT`.

### Оптимистическая блокировка

Оптимистическая блокировка обычно использует технику проверки версий. Это подразумевает, что каждая строка в таблице имеет версионный номер или временную метку, которая обновляется при каждом изменении строки.

**Пример:**

Добавим в таблицу `accounts` колонку `version`. Теперь каждое обновление должно учитывать текущую версию.

```sql
-- Предполагаем, что версия и баланс были получены ранее в приложении
-- Текущие значения: balance = 200, version = 3

BEGIN;

-- Обновить строку только если версия не изменилась
UPDATE accounts
SET balance = balance + 100, version = version + 1
WHERE id = 1 AND version = 3;

-- Проверить, была ли строка обновлена
IF NOT FOUND THEN
    RAISE EXCEPTION 'Конфликт версий: данные были изменены другой транзакцией.';
END IF;

COMMIT;
```

Здесь мы пытаемся обновить запись, увеличив баланс и версию, только если текущая версия соответствует ожидаемой (то есть версии, с которой мы начали). Если запись была изменена другой транзакцией (и версия увеличилась), оператор `UPDATE` не изменит ни одной строки (`NOT FOUND` будет истинным), и транзакция выдаст исключение.

### Вывод

Выбор между пессимистическим и оптимистическим подходами зависит от конкретных требований приложения. Пессимистическая блокировка хорошо подходит для сценариев с высокой конкуренцией, где риск взаимных блокировок или других проблем конкуренции относительно низок. Оптимистическая блокировка обычно более эффективна в средах с меньшей конкуренцией или когда блокировки могут сильно ухудшить производительность из-за длительного ожидания.

--- 

🐸🐸🐸 Материалы 🐸🐸🐸
1) lock
   https://habr.com/ru/companies/tensor/articles/488024/
   https://www.postgresql.org/docs/9.1/functions-admin.html
   https://www.postgresql.org/docs/current/sql-select.html
   https://habr.com/ru/companies/postgrespro/articles/463819/

2) анализ запросов
   https://www.postgresql.org/docs/current/sql-explain.html
   https://habr.com/ru/articles/203320/